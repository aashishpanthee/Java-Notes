b. hashCode()
=> For every object, a unique number is generated by JVM which is nothing but hashCode. 
   hashCode won't represent address of object.
   JVM will use hashCode while saving objects into hashing related data-structures like hashTable, hashMap, hashSet, etc.
   The main advantage of saving objects based on hashCode is search operation will become easy (the most powerful search algorithm upto today is hashing).
   
   If you are giving chance to Object class hashCode method , it will generate hashCode based on address of the object. It doesn't mean hashCode represents address of the object.
   
   -Based on our requirement we can override hashCode method in our class to generate  our own hashCodes.
    Overriding hashCode() method is said to be proper, if and only if for every object we have to generate a unique number as hashCode.
      i. 
      class Studen{
        public int hashCode(){
          return 100;
        }
      }
        This is improper way.
        This is improper way of over-riding hashCode() method because for all student objects, we are generating same number as hashCode.
    
     ii.
      class Student{
        public int hashCode(){
          return rollno;
        }
      }
        This is proper/appropriate way.
        This is proper way of over-riding hashCode() method because we are generating a different number as hashCode for every object.


************* toString() VS hashCode() ***************
If we are giving the chance to Object class toString() method, it will internally call hashCode() method.
If we are over-riding toString() method  then our toString() method may not call hashCode() method.


c. equals()
=> We can use equals() method to check equality of two objects. For eg: obj1.equals(obj2)

-- If our class doesn't contain equals() method then Object class's equals() method will be executed.
      class Program{
        String name;
        int rollno;
        Program(String name, int rollno){
          this.name = name;
          this.rollno = rollno;
        }
        public static void main(String[] args){
          Program p1 = new Program("John", 101);
          Program p2 = new Program("Doe", 102);
          Program p3 = new Program("John", 101);
          Program p4 = p1;
          System.out.println(p1.equals(p2)); //Output:false
          System.out.println(p1.equals(p3)); //Output:false
          System.out.println(p1.equals(p4));  //Output:true
        }
      }
  In the above example , Object class's equals() method got executed which is meant for Reference Comparison (address comparison). i.e. if two references pointing to the same object then only .equals() method returns true.

-- Based on our requirement, we can override equals() method for Content Comparison.
   While over-riding equals() method for Content Comparison , we have to take care about the following:
    i. What is the meaning of equality ? ie. whether we have to check only names, or only rollno or both.
    ii. If we are passing different type of object , our equals() method should not rise ClassCastException. ie. we have to handle ClassCastException to return false.
    iii. If we are passing Null argument then our equals() method should not rise NullPointerException. ie. we have to handle NullPointerException to return false.
    The following is the proper way of over-riding equals() method for Student class Content Comparison.

class Student{
  String name;
  int rollno;
  Student(String name, int rollno){
    this.name = name;
    this.rollno = rollno;
  }
  public boolean equals(Object obj){
    try{
    String name1 = this.name;
    int rollno1 = this.rollno;
    Student student = (Student)obj;
    String name2 = student.name;
    int rollno2 = student.rollno;
    if(name1.equals(name2) && rollno1 == rollno2){
      return true;
    }
    else{
      return false;
    }
    }
  catch(ClassCastException e){
    return false;
  }
  catch(NullPointerException e){
    return false;
  }
  }
  public static void main(String[] args){
    Student p1 = new Student("John", 101);
    Student p2 = new Student("Doe", 102);
    Student p3 = new Student("John", 101);
    Student p4 = p1;
    System.out.println(p1.equals(p2));
    System.out.println(p1.equals(p3));
    System.out.println(p1.equals("aashish"));
    System.out.println(p1.equals(null));
    System.out.println(p1.equals(p4));
  }
}
   

